Hystrix是基于单机应用的熔断限流框架
根据熔断器的滑动窗口判断当前请求是否可以执行
线程竞争实现“半关闭”状态，拿一个请求试试是否可以关闭熔断器
线程池隔离将请求丢到线程池中运行，限流依靠线程池拒绝策略
信号量隔离在当前线程中运行，限流依靠并发请求数
当信号量竞争失败/线程池队列满，就进入限流模式，执行fallback
当熔断器开启，就熔断请求，执行fallback　

包裹请求：使用HystrixCommand（或者HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中执行。这使用了设计模式中的“命令模式”。
跳闸机制：当某服务的错误率超过一定阀值时，Hystrix可以自动或者手动跳闸，停止请求该服务一段时间。
资源隔离：Hystrix为每个依赖都维护了一个小型的线程池（或者信号量）。如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排队等候，从而加速失败判断
监控：Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求等。
回退机制：当请求失败、超时、被拒绝，或当断路器打开时，执行回退逻辑。回退逻辑可由开发人员自行提供，例如返回一个缺省值。
自我修复：断路器打开一段时间后，会自动进入“半开”状态。


Hystrix的隔离策略有两种：线程隔离和信号量隔离。
THREAD(线程隔离）：使用该方式，HystrixCommand将会在单独的线程执行，并发请求受线程池数据的限制
SEMAPHORE(信号量隔离）：使用该方式，HystrixCommand将会在调用线程上执行，开销相对较小，并发请求收到信号量个数的限制
Hystrix中默认使用线程隔离（THREAD）,因为这种方式有一个除网络超时以外的额外保护层。

一般来说，只有当调用负债非常高时（至少每秒数百次）才需要使用信号量隔离，因为这种场景使用线程隔离开销会比较高，信号量格式一般仅适用于非网络调用的隔离。
可以使用execution.isolation.strategy属性指定隔离策略。

